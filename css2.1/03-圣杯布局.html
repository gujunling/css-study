<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>前端小记-圣杯布局</title>
    <style type="text/css">
      * {
        margin: 0;
        padding: 0;
      }
      body{
          min-width: 600px;
      }
      .header,
      .footer {
        height: 80px;
        text-align: center;
        border: 1px solid;
        background: #bfa;
      }
      .content {
        padding: 0 200px;
        overflow: hidden;
        /*  注意，设置了content元素的padding后，此时的内容区宽度已经变小了，若想让左右两侧的元素出来则需要通过给左右两侧元素设置相对定位，使其出来即可。 */
      }
      .content .middle {
        float: left;
        width: 100%;
        background: pink;
        /* padding: 0 200px;  */
        /* 此时不能如此设置，因为此时的width已经设置过了，再设置padding就相当于是给middle元素的左右增加了200px ，应该给content容器增加200px的左右padding*/
      }
      .content .left {
        float: left;
        width: 200px;
        /* margin为负值，只改变元素的边界，不改变元素的位置 */
        /* 设置左边元素的边界为向左移动一个content宽度，但注意，这样只是改变了边界，元素的位置并没有改变，
        虽然元素上去了，这是因为left的边界改变了，content元素自动向下拓展了，此时的margin-left值必须要和content元素的width值完全相同 */
        margin-left: -100%;
        background: bisque;
        position: relative;
        left: -200px;
        top: 0;
      }
      .content .right {
        float: left;
        width: 200px;
        margin-left: -200px;
        background: green;
        position: relative;
        right: -200px;
        top: 0;
      }
      /* 清除content元素的浮动产生的影响 */
      .clearfix {
        *zoom: 1;
      }
      .clearfix:after {
        content: "";
        display: block;
        clear: both;
      }

      /* 设置伪等高布局，保证中间的三列布局是等高的，不会出现一个高一个低的现象 */
      .content .middle,
      .content .left,
      .content .right {
          padding-bottom: 10000px;
          margin-bottom: -10000px;
      }
    </style>
  </head>
  <body>
    <!-- 
        1. 两边固定，中间自适应。
        2. 中间项的内容要完整显示。
        3. 中间项要优先加载。

        圣杯布局技术点总结：

           浮动：搭建完整的布局框架
           margin为负值：调整旁边两列的位置（使三列布局显示到一行上）
           使用相对定位：调整旁边两侧的位置（使两侧元素的位置调整到两头，暴露出来）
     -->
    <div class="header">
      header
      每个块级元素都从新的一行开始，并且其后的元素也另起一行。（一个块级元素独占一行）
    </div>
    <div class="content clearfix">
      <div class="middle">
        finally()
        方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。
        这避免了同样的语句需要在then()和catch()中各写一次的情况。
        finally()
        方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。
        这避免了同样的语句需要在then()和catch()中各写一次的情况。
        finally()
        方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。
        这避免了同样的语句需要在then()和catch()中各写一次的情况。
        finally()
        方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。
        这避免了同样的语句需要在then()和catch()中各写一次的情况。
        finally()
        方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。
        这避免了同样的语句需要在then()和catch()中各写一次的情况。
        finally()
        方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。
        这避免了同样的语句需要在then()和catch()中各写一次的情况。
        finally()
        方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。
        这避免了同样的语句需要在then()和catch()中各写一次的情况。
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        finally()
        方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。
        这避免了同样的语句需要在then()和catch()中各写一次的情况。
      </div>
      <div class="left">left</div>
      <div class="right">right</div>
    </div>
    <div class="footer">
      footer
      元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。
    </div>
  </body>
</html>
